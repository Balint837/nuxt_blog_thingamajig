{
  "categories": [
    {
      "name": "Feature showcase",
      "description": "Me ranting about cool new features",
      "id": 1
    },
    {
      "name": "Feature ideas",
      "description": "Me ranting about stuff that could be added",
      "id": 2
    },
    {
      "name": "Critique",
      "description": "Me ranting about how much I don't like something",
      "id": 3
    },
    {
      "name": "TIL",
      "description": "Me ranting about obscure features that may or may not be new",
      "id": 4
    }
  ],
  "posts": [
    {
      "title": "Generic Attributes",
      "content": "<h1 id=\"exploring-generic-attributes-in-c-11\">Exploring Generic Attributes in C# 11</h1>\n<p>C# 11 introduced <strong>Generic Attributes</strong>, a powerful new feature that enhances the flexibility and type safety of attributes in .NET. In this blog post, we&#39;ll dive into the original behavior of attributes with type arguments, the challenges it presented, and how generic attributes address these limitations.</p>\n<h2 id=\"attributes-in-c-the-old-way\">Attributes in C#: The Old Way</h2>\n<p>Attributes in C# have been a cornerstone for annotating metadata on classes, methods, properties, and more. Prior to C# 11, attributes could accept types as arguments, but the experience was not as seamless as it could be. For example:</p>\n<pre><code>[TypeArgumentAttribute(<span class=\"hljs-keyword\">typeof</span>(SomeClass))]\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyClass</span>\n</span>{\n    <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre><p>This approach had several shortcomings:</p>\n<ul>\n<li><strong>No Type Constraints:</strong> Since the type was passed as a <code>Type</code> object, you couldn’t enforce compile-time constraints on the type argument. Any type could be passed, even if it didn’t make sense in context.</li>\n<li><strong>No Type-Specific Behavior:</strong> The attribute itself couldn’t directly use the type for generic logic or enforce specific behaviors tied to the type.</li>\n<li><strong>Verbosity:</strong> Using <code>typeof</code> added verbosity and reduced clarity in many scenarios.</li>\n<li><strong>Reflection Overhead:</strong> Working with the <code>Type</code> object often required additional reflection at runtime to perform operations or verify constraints, which could be error-prone and less performant.</li>\n</ul>\n<h2 id=\"introducing-generic-attributes-in-c-11\">Introducing Generic Attributes in C# 11</h2>\n<p>To address these challenges, <strong>Generic Attributes</strong> were introduced in C# 11. With this feature, you can now define and use attributes that take generic type parameters directly. This improvement brings <strong>compile-time type checking</strong> and eliminates the need for <code>typeof</code>.</p>\n<h3 id=\"defining-a-generic-attribute\">Defining a Generic Attribute</h3>\n<p>Here’s an example of how you can define a generic attribute:</p>\n<pre><code><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">GenericAttribute</span>&lt;<span class=\"hljs-type\">T</span>&gt; : <span class=\"hljs-type\">Attribute</span></span>\n{\n    <span class=\"hljs-keyword\">public</span> GenericAttribute()\n    {\n        <span class=\"hljs-comment\">// Type-specific logic can be added here</span>\n    }\n}\n</code></pre><h2 id=\"using-a-generic-attribute\">Using a Generic Attribute</h2>\n<p>Using a generic attribute is straightforward:</p>\n<pre><code>[GenericAttribute&lt;SomeClass&gt;]\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyClass</span>\n</span>{\n    <span class=\"hljs-comment\">// …</span>\n}\n</code></pre><p>In this example:</p>\n<ul>\n<li>The attribute now directly references the type <code>SomeClass</code> as a generic parameter.</li>\n<li>You benefit from <strong>compile-time type checking</strong> and constraints.</li>\n</ul>\n<h2 id=\"key-benefits-of-generic-attributes\">Key Benefits of Generic Attributes</h2>\n<ol>\n<li><strong>Compile-Time Type Checking:</strong> Generic attributes enforce type constraints, ensuring that only valid types are used:</li>\n</ol>\n<pre><code><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyGenericAttribute</span>&lt;<span class=\"hljs-type\">T</span>&gt; : <span class=\"hljs-type\">Attribute</span></span>\n    where T : <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span>, <span class=\"hljs-type\">new</span></span>()\n{\n    <span class=\"hljs-comment\">// …</span>\n}\n\n[MyGenericAttribute&lt;int&gt;] <span class=\"hljs-comment\">// Compile-time error: 'int' does not satisfy 'class, new()'</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">InvalidClass</span> </span>{ }\n</code></pre><ol>\n<li><strong>Improved Type Safety:</strong> Directly referencing the type avoids runtime errors caused by invalid type casts or mismatched expectations.</li>\n<li><strong>Clearer Syntax:</strong> The new syntax eliminates the need for <code>typeof</code>, making the code cleaner and more expressive.</li>\n<li><strong>Enhanced Performance:</strong> Since the type is known at compile-time, there is no need for reflection to determine the type at runtime, resulting in better performance.</li>\n</ol>\n<h2 id=\"considerations\">Considerations</h2>\n<p>While generic attributes are a significant improvement, there are a few considerations to keep in mind:</p>\n<ul>\n<li><strong>CLR Support:</strong> The .NET runtime does not natively support attributes with generic type parameters. This means the feature relies on compiler-generated code and metadata tricks. You cannot directly inspect generic attributes using standard reflection APIs.</li>\n<li><strong>Tooling Updates:</strong> Ensure your tools (e.g., analyzers, reflection libraries) are updated to recognize and work with generic attributes properly.</li>\n</ul>\n",
      "categoryId": 1,
      "tagIds": [
        1,
        2
      ],
      "createdAt": 1743438567,
      "id": 1
    },
    {
      "title": "Static Abstract and Generic Math",
      "content": "<h1 id=\"solving-the-generic-number-problem-in-c-11\">Solving the Generic Number Problem in C# 11</h1>\n<p>C# is a powerful and versatile programming language, but for years, it lacked one critical feature: a generic way to work with numeric types. Until C# 11, writing generic code for mathematical operations was clunky, often relying on workarounds that sacrificed clarity or performance. Thankfully, with C# 11, we now have static abstract interface members and the new <code>INumber</code> interface, which together address this long-standing limitation.</p>\n<h2 id=\"the-problem-no-generic-number-type-in-c\">The Problem: No Generic Number Type in C</h2>\n<p>Consider a scenario where you want to write a generic function to sum elements of a collection, regardless of whether they are <code>int</code>, <code>double</code>, or some other numeric type. Without a generic numeric type, you would need to write multiple overloads or use reflection or dynamic typing, which introduces runtime overhead and lack of type safety.</p>\n<p>Here’s a typical example of the problem:</p>\n<pre><code>public <span class=\"hljs-built_in\">T</span> <span class=\"hljs-built_in\">Sum</span>&lt;<span class=\"hljs-built_in\">T</span>&gt;(IEnumerable&lt;<span class=\"hljs-built_in\">T</span>&gt; values) where <span class=\"hljs-built_in\">T</span> <span class=\"hljs-symbol\">:</span> ??? // What constraint works for numbers?\n{\n    <span class=\"hljs-built_in\">T</span> <span class=\"hljs-built_in\">sum</span> = default;\n    foreach (<span class=\"hljs-built_in\">var</span> <span class=\"hljs-built_in\">value</span> in values)\n    {\n        <span class=\"hljs-built_in\">sum</span> += <span class=\"hljs-built_in\">value</span>; // Compile-<span class=\"hljs-built_in\">time</span> err<span class=\"hljs-symbol\">or:</span> operator '+' cannot be applied to operands of <span class=\"hljs-built_in\">type</span> '<span class=\"hljs-built_in\">T</span>'\n    }\n    return <span class=\"hljs-built_in\">sum</span>;\n}\n</code></pre><p>C# did not previously have a way to constrain <code>T</code> to only numeric types or to use operators like <code>+</code> in a generic context. This limitation made it impossible to write truly generic numeric code.</p>\n<h3 id=\"dynamic-also-has-its-own-issues\">Dynamic Also Has Its Own Issues</h3>\n<pre><code><span class=\"hljs-keyword\">public</span> T Sum&lt;T&gt;(T[] numbers) <span class=\"hljs-keyword\">where</span> T : <span class=\"hljs-keyword\">struct</span>\n{\n    <span class=\"hljs-keyword\">dynamic</span> total = <span class=\"hljs-keyword\">default</span>(T);\n    <span class=\"hljs-keyword\">foreach</span> (<span class=\"hljs-keyword\">var</span> number <span class=\"hljs-keyword\">in</span> numbers)\n    {\n        total += number; <span class=\"hljs-comment\">// Uses dynamic, no compile-time safety</span>\n    }\n    <span class=\"hljs-keyword\">return</span> total;\n}\n</code></pre><ul>\n<li><strong>Lack of Type Safety:</strong> Using <code>dynamic</code> means there’s no compile-time verification, making it prone to runtime errors.</li>\n<li><strong>Boxing and Performance Issues:</strong> Using non-generic constructs like <code>dynamic</code> or <code>object</code> leads to boxing/unboxing and runtime type checks, degrading performance.</li>\n</ul>\n<p>Clearly, a better solution was needed.</p>\n<h2 id=\"enter-static-abstract-interface-members\">Enter Static Abstract Interface Members</h2>\n<p>C# 11 introduces <strong>static abstract interface members</strong>, a game-changing feature that allows interfaces to define static methods, operators, or properties that implementing types must provide. This means you can now define interfaces that require types to implement specific operators, like <code>+</code>, <code>-</code>, or <code>*</code>.</p>\n<h2 id=\"the-inumber-interface\">The <code>INumber</code> Interface</h2>\n<p>C# 11 introduces a new interface hierarchy in the <code>System.Numerics</code> namespace, including the <code>INumber</code> interface. This interface provides a standardized way to work with numeric types generically. Here&#39;s what it looks like in practice:</p>\n<pre><code>public interface INumber&lt;<span class=\"hljs-built_in\">T</span>&gt; <span class=\"hljs-symbol\">:</span> IComparable&lt;<span class=\"hljs-built_in\">T</span>&gt;, IEquatable&lt;<span class=\"hljs-built_in\">T</span>&gt;, IAdditiveIdentity&lt;<span class=\"hljs-built_in\">T</span>, <span class=\"hljs-built_in\">T</span>&gt;\n    where <span class=\"hljs-built_in\">T</span> <span class=\"hljs-symbol\">:</span> INumber&lt;<span class=\"hljs-built_in\">T</span>&gt;\n{\n    static abstract <span class=\"hljs-built_in\">T</span> operator +(<span class=\"hljs-built_in\">T</span> <span class=\"hljs-built_in\">left</span>, <span class=\"hljs-built_in\">T</span> <span class=\"hljs-built_in\">right</span>);\n    static abstract <span class=\"hljs-built_in\">T</span> operator -(<span class=\"hljs-built_in\">T</span> <span class=\"hljs-built_in\">left</span>, <span class=\"hljs-built_in\">T</span> <span class=\"hljs-built_in\">right</span>);\n    static abstract <span class=\"hljs-built_in\">T</span> Zero { get; }\n    static abstract <span class=\"hljs-built_in\">T</span> One { get; }\n}\n</code></pre><h2 id=\"writing-a-generic-math-method\">Writing a Generic Math Method</h2>\n<p>Using <code>INumber</code>, you can now write generic numeric code with type safety and great performance:</p>\n<pre><code>public <span class=\"hljs-built_in\">T</span> <span class=\"hljs-built_in\">Sum</span>&lt;<span class=\"hljs-built_in\">T</span>&gt;(<span class=\"hljs-built_in\">T</span>[] numbers) where <span class=\"hljs-built_in\">T</span> <span class=\"hljs-symbol\">:</span> INumber&lt;<span class=\"hljs-built_in\">T</span>&gt;\n{\n    <span class=\"hljs-built_in\">T</span> total = T.Zero;\n    foreach (<span class=\"hljs-built_in\">var</span> number in numbers)\n    {\n        total += number; \n    }\n    return total;\n}\n</code></pre><p>This approach ensures:</p>\n<ul>\n<li><strong>Compile-Time Safety:</strong> Only types implementing <code>INumber</code> can be used.</li>\n<li><strong>Performance:</strong> No boxing/unboxing or reliance on <code>dynamic</code>.</li>\n<li><strong>Clarity:</strong> The code is clean, concise, and expressive.</li>\n</ul>\n<p>By combining this with dependency injection, you can create flexible, maintainable systems that leverage modern C# features to their fullest potential.<br>If you&#39;re building applications that rely on numeric computations, it&#39;s time to explore the possibilities offered by C# 11. <strong>Happy coding!</strong></p>\n",
      "categoryId": 1,
      "tagIds": [
        1,
        2
      ],
      "createdAt": 1743438674,
      "id": 2
    },
    {
      "title": "File-Scoped Access Modifier",
      "content": "<h1 id=\"introducing-the-file-access-modifier-in-c-11\">Introducing the file Access Modifier in C# 11</h1>\n<p>C# 11 introduces a new access modifier: <code>file</code>. This feature addresses a gap in encapsulation by providing a way to limit the accessibility of types or members to the file in which they are declared. It’s a useful addition that enhances modularity and helps prevent unintended usage of implementation details outside their intended context.</p>\n<p>In this post, we’ll explore how the file access modifier works, its practical use cases, and how it is enforced in the resulting MSIL (Microsoft Intermediate Language).</p>\n<h2 id=\"the-problem-internal-isn-t-always-private-enough\">The Problem: Internal Isn’t Always Private Enough</h2>\n<p>Before C# 11, the <code>internal</code> access modifier was the closest you could get to restricting a type to a specific project or assembly. However, there are times when you want to limit access even further—to just the file in which the type or member is declared. Developers often resorted to using private nested types or other workarounds.</p>\n<p>Consider this example:</p>\n<pre><code><span class=\"hljs-comment\">// File: Helpers.cs</span>\n<span class=\"hljs-keyword\">internal</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelperClass</span>\n{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">DoSomething</span>(<span class=\"hljs-params\"></span>) </span>{ <span class=\"hljs-comment\">/* ... */</span> }\n}\n</code></pre><p>Although HelperClass is <code>internal</code>, it is still accessible to all other code within the same assembly. If you want to keep HelperClass entirely local to the file, there was no simple way to achieve this—until now.</p>\n<h2 id=\"-the-solution-the-file-modifier\">--- The Solution: The <code>file</code> Modifier</h2>\n<p>The <code>file</code> access modifier restricts the visibility of a type or member to the file in which it is declared. Here’s an example:</p>\n<pre><code>file <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FileScopedHelper</span>\n{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">DoSomething</span>(<span class=\"hljs-params\"></span>) </span>{ <span class=\"hljs-comment\">/* ... */</span> }\n}\n</code></pre><p>In this example, <code>FileScopedHelper</code> is not accessible from any other file in the same assembly. This provides a cleaner way to define helper types or implementation details that should not leak outside the file.</p>\n<h2 id=\"how-file-is-enforced-the-msil-perspective\">How file Is Enforced: The MSIL Perspective</h2>\n<p>The <code>file</code> modifier is enforced at the compiler level and does not translate directly to a specific access modifier in MSIL. Instead, the C# compiler employs name mangling to ensure that file-scoped types cannot be accessed outside their defining file. Let’s inspect the MSIL output to see how this works.</p>\n<h3 id=\"c-code-with-file\">C# Code with file</h3>\n<pre><code>file <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FileScopedHelper</span>\n{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">DoSomething</span>(<span class=\"hljs-params\"></span>) </span>{ <span class=\"hljs-comment\">/* ... */</span> }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PublicClass</span>\n{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Test</span>(<span class=\"hljs-params\"></span>)\n    </span>{\n        FileScopedHelper.DoSomething();\n    }\n}\n</code></pre><h3 id=\"msil-output\">MSIL Output</h3>\n<p>Compiling this code and examining the resulting MSIL reveals the following:</p>\n<pre><code>.<span class=\"hljs-keyword\">class</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">auto</span> ansi <span class=\"hljs-string\">'&lt;_&gt;FD2E2ADF7177B7A8AFDDBC12D1634CF23EA1A71020F6A1308070A16400FB68FDE__FileScopedHelper'</span>\n{\n    .method <span class=\"hljs-keyword\">public</span> hidebysig <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> DoSomething() cil managed\n    {\n        <span class=\"hljs-comment\">// Method implementation</span>\n    }\n}\n\n.<span class=\"hljs-keyword\">class</span> <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">auto</span> ansi PublicClass\n{\n    .method <span class=\"hljs-keyword\">public</span> hidebysig <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> Test() cil managed\n    {\n        <span class=\"hljs-comment\">// Call to FileScopedHelper.DoSomething</span>\n        call <span class=\"hljs-keyword\">void</span> <span class=\"hljs-string\">'&lt;_&gt;FD2E2ADF7177B7A8AFDDBC12D1634CF23EA1A71020F6A1308070A16400FB68FDE__FileScopedHelper'</span>::DoSomething()\n        ret\n    }\n}\n</code></pre><p>The compiler correctly handles calls to the file-scoped type within the same file but ensures that such references cannot escape.</p>\n<h2 id=\"practical-use-cases-for-file\">Practical Use Cases for file</h2>\n<ul>\n<li>Encapsulation for Helper Types: Limit access to utility classes or implementation details, preventing them from polluting the assembly-wide namespace.</li>\n<li>Cleaner Code: Replace nested private types with standalone file-scoped types for better readability and modularity.</li>\n<li>Library Design: Ensure internal logic remains isolated from public-facing APIs without relying on conventions or naming patterns.</li>\n</ul>\n<h2 id=\"limitations\">Limitations</h2>\n<ul>\n<li>Not for Members: The file modifier applies only to top-level types. Members (e.g., methods, properties) within types cannot be file-scoped.</li>\n<li>No runtime enforcement: Since file is enforced by the C# compiler using name mangling, the MSIL representation doesn’t inherently &quot;know&quot; about the file modifier. This means reflective access might bypass the intended restriction, just like with the internal and private access modifiers.</li>\n</ul>\n",
      "categoryId": 1,
      "tagIds": [
        1,
        2
      ],
      "createdAt": 1743438751,
      "id": 3
    }
  ],
  "tags": [
    {
      "name": "C#11",
      "id": 1
    },
    {
      "name": "NET7",
      "id": 2
    },
    {
      "name": "NET8",
      "id": 3
    },
    {
      "name": "NET9",
      "id": 4
    },
    {
      "name": "C#12",
      "id": 5
    },
    {
      "name": "C#13",
      "id": 6
    },
    {
      "name": "NET Framework",
      "id": 7
    }
  ],
  "users": [
    {
      "name": "admin",
      "passwordHash": "$2b$10$cqqAyZzVEhU/Ys8K9y5XhOD6SJ5wPxV6dt09NnO93LlZwKOGtGNyu",
      "role": "admin"
    }
  ]
}